{"version":3,"sources":["../src/Shaders.js"],"names":["invariant","require","INLINE_NAME","_uid","names","shaders","shadersCompileResponses","shadersCompileResults","shadersReferenceCounters","surfaceInlines","previousSurfaceInlines","makeDeferred","defer","p","Promise","resolve","reject","promise","implDefer","implementation","add","existingId","findShaderId","shader","id","name","then","impl","result","remove","getShadersToRemove","Object","keys","filter","map","parseInt","scheduled","gcNow","clearTimeout","forEach","scheduleGC","noDebounce","length","setTimeout","sameShader","a","b","frag","logError","console","error","Shaders","_onSurfaceWillMount","surfaceId","_onSurfaceWillUnmount","_beforeSurfaceBuild","_resolve","idOrObject","compileHandler","catch","get","inlines","push","_afterSurfaceBuild","create","obj","onAllCompile","compileErrors","compileResults","all","key","freeze","getCompilationResult","getCompilationPromise","list","exists","setImplementation","module","exports"],"mappings":"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","file":"Shaders.js","sourcesContent":["const invariant = require(\"invariant\");\n\nconst INLINE_NAME = \"<inline>\";\n\nlet _uid = 1;\nconst names = {}; // keep names\nconst shaders = {}; // keep shader objects\nconst shadersCompileResponses = {}; // keep promise of compile responses\nconst shadersCompileResults = {}; // keep only the successful result\nconst shadersReferenceCounters = {}; // reference count the shaders created with Shaders.create()/used inline so we don't delete them if one of 2 dups is still used\n\nconst surfaceInlines = {};\nconst previousSurfaceInlines = {};\n\nfunction makeDeferred() {\n  var defer = {};\n  var p = new Promise(function(resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  defer.promise = p;\n  return defer;\n}\n\nlet implDefer = makeDeferred();\nconst implementation = implDefer.promise;\n\nconst add = shader => {\n  const existingId = findShaderId(shaders, shader);\n  const id = existingId || _uid ++;\n  let promise;\n  if (!existingId) {\n    names[id] = shader.name;\n    shaders[id] = shader;\n    shadersReferenceCounters[id] = 0;\n    shadersCompileResponses[id] = promise =\n    implementation\n      .then(impl => impl.add(id, shader))\n      .then(result => shadersCompileResults[id] = result);\n  }\n  else {\n    promise = shadersCompileResponses[id];\n  }\n  return { id, promise };\n};\n\nconst remove = id => {\n  delete shaders[id];\n  delete names[id];\n  delete shadersReferenceCounters[id];\n  delete shadersCompileResponses[id];\n  implementation.then(impl => impl.remove(id));\n};\n\nconst getShadersToRemove = () =>\n  Object.keys(shadersReferenceCounters)\n  .filter(id => shadersReferenceCounters[id] <= 0)\n  .map(id => parseInt(id, 10));\n\nlet scheduled;\nconst gcNow = () => {\n  clearTimeout(scheduled);\n  getShadersToRemove().forEach(remove);\n};\nconst scheduleGC = () => {\n  // debounce the shader deletion to let a last chance to a future dup shader to appear\n  // the idea is also to postpone this operation when the app is not so busy\n  const noDebounce = getShadersToRemove().length > 20;\n  if (!noDebounce) clearTimeout(scheduled);\n  scheduled = setTimeout(gcNow, 500);\n};\n\nconst sameShader = (a, b) => a.frag === b.frag;\n\nconst findShaderId = (shaders, shader) => {\n  for (let id in shaders) {\n    if (sameShader(shaders[id], shader)) {\n      return parseInt(id, 10);\n    }\n  }\n  return null;\n};\n\nconst logError = shader => error =>\n  console.error( //eslint-disable-line no-console\n    \"Shader '\" + shader.name + \"' failed to compile:\\n\" + error\n  );\n\nconst Shaders = {\n\n  _onSurfaceWillMount (surfaceId) {\n    surfaceInlines[surfaceId] = [];\n  },\n\n  _onSurfaceWillUnmount (surfaceId) {\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    delete surfaceInlines[surfaceId];\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  _beforeSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId] = surfaceInlines[surfaceId];\n    surfaceInlines[surfaceId] = [];\n  },\n\n  // Resolve the shader field of GL.Node.\n  // it can be an id (created with Shaders.create) or an inline object.\n  _resolve (idOrObject, surfaceId, compileHandler) {\n    if (typeof idOrObject === \"number\") return idOrObject;\n    const { id, promise } = add({ name: INLINE_NAME, ...idOrObject });\n    if (compileHandler) {\n      promise.then(\n        result => compileHandler(null, result),\n        error => compileHandler(error));\n    }\n    else {\n      promise.catch(logError(Shaders.get(id)));\n    }\n    const inlines = surfaceInlines[surfaceId];\n    inlines.push(id);\n    return id;\n  },\n\n  _afterSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]++);\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  //~~~ Exposed methods ~~~ //\n\n  // Create shaders statically\n  create (obj, onAllCompile) {\n    invariant(typeof obj === \"object\", \"config must be an object\");\n    const result = {};\n    const compileErrors = {}, compileResults = {};\n    Promise.all(Object.keys(obj).map(key => {\n      const shader = obj[key];\n      invariant(typeof shader === \"object\" && typeof shader.frag === \"string\",\n      \"invalid shader given to Shaders.create(). A valid shader is a { frag: String }\");\n      const {id, promise} = add({ name: key, ...shader });\n      result[key] = id;\n      shadersReferenceCounters[id] ++;\n      return promise.then(\n        result => compileResults[key] = result,\n        error => compileErrors[key] = error\n      );\n    }))\n    .then(() => {\n      if (onAllCompile) {\n        onAllCompile(\n          Object.keys(compileErrors).length ? compileErrors : null,\n          compileResults);\n      }\n      else {\n        Object.keys(compileErrors).forEach(key =>\n          logError(Shaders.get(result[key]))(compileErrors[key]));\n      }\n    });\n    return result;\n  },\n\n  // Get the shader object by id.\n  get (id) {\n    return Object.freeze(shaders[id]);\n  },\n\n  // Synchronously retrieve the successful compilation response.\n  // returns or ShaderResult object or null if there were a failure or not ready\n  getCompilationResult (id) {\n    return shadersCompileResults[id] || null;\n  },\n\n  // Get the promise of the compilation state. Allows you to wait for compilation\n  // and also map on errors.\n  // Returns null only if you never have created this shader.\n  getCompilationPromise (id) {\n    return shadersCompileResponses[id] || null;\n  },\n\n  // List all shader ids that exists at the moment.\n  list () {\n    return Object.keys(shaders);\n  },\n\n  // Check if a shader exists\n  exists (id) {\n    return id in shaders;\n  },\n\n  gcNow,\n\n  setImplementation: impl => {\n    invariant(implDefer, \"Shaders.setImplementation can be called only once\");\n    implDefer.resolve(impl);\n    implDefer = null;\n  },\n\n  implementation\n};\n\nmodule.exports = Object.freeze(Shaders);\n"]}